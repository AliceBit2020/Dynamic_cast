#include <iostream>
#include"Dolphin.h"
#include "Elephant.h"
#include "Parrot.h"
#include "Animal.h"
using namespace std;


void main()
{
	

	Animal** arr = new Animal * [3];
	arr[0] = new Dolphin("Dolphin");
	arr[1] = new Parrot("Parrot");
	arr[2] = new Elephant("Elephant");

	//for (int i = 0; i < 3; i++)
	//	arr[i]->Print();///// 

	arr[0]->Print();///// Dolphin::Print() тому що метод virtual , Animal* arr[0]
	arr[1]->Print();///// 
	arr[2]->Print();///// 



	

	////Тобто через вказівник на батьківський клас можемо визивати методи дочірніх  класів(але virtual)
	////arr[0] дивиться на обьєкт Dolphin, але це вказівник на Animal*, тому нема доступу до методу Swim()
	////Проблема: через вказівник на батьківський клас не бачимо специфічні методи дочірнього класу( тобто не бачимо Swim(),Fly(), Stamp()
	///Через вказівник на батьківський клас бачимо лише ті методи котрі обьявлені в батьківському класі

	///Два методи вирішення
	///1.Додати у батьківський класс всі особливі методи/Отримуємо перенавантаження батьківського класу

	///2. Зробити понижувальне перетворення типів від Animal*    до  Dolphin*, спускаємось від батька до дочірнього класу

	//arr[0].Swim();

	Animal* a_ptr= new Dolphin("Dolphin");////  високий рівень абстракції, працюємо через вказівник на батьківський клас
	
	
	Dolphin* ptr = dynamic_cast<Dolphin*>(a_ptr);//////   понижуємо рівень абстракції  ,перетворення від батьківського класу до дочірнього

	if (ptr)
	{
		ptr->Print();
		ptr->Swim();
	}


	Parrot* ptrParrot= dynamic_cast<Parrot*>(a_ptr);/////  return 0



	if(ptrParrot != nullptr )
	cout << ptrParrot << endl;


	////Тут ми відмовились від загального вказівника на Animal* і звернулись до конкретного дочірнього Dolphin* ptr, тим самим ми відмовились від ідеї узагальнюючого програмування
	///  знизили рівень абстракції



	/*
	понижувальне перетворення-перетворення вказівника типу батька до типу потомка(якщо 
	вказівник на батька дійсно дивиться на потомка)
	1. Якщо перетворення не можливе - поверне 0 , а не помилку
	2. Перетворення можливе для поліморфних типів (базовий клас має містити віртуальний метод)
	2.a Перетворення можливе для наслідування зі спеціфікатором public
	3. Перетворення повертає не 0 :
	
-	Base* ptr =new Child();
	Cild* ptr_ch=dynamic_cast<Child*>(ptr)

	4. Поверне 0

	Base* ptr =new Base();
	Cild* ptr_ch=dynamic_cast<Child*>(ptr)
	*/


}